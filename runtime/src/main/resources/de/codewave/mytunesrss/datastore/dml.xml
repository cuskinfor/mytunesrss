<?xml version="1.0" encoding="UTF-8"?>

<statements>

    <statement name="findAlbums">
        <parameter name="index" type="java.lang.Integer"/>
        <conditionals>track,filter,artist,album,year</conditionals>
        <sql>
            <![CDATA[
            SELECT a.name AS albumname, a.track_count AS track_count, a.artist_count AS artist_count, a.artist AS artist, a.image_hash AS image_hash, a.year AS year
            FROM album a <track>, track t</track>
            WHERE ((:index < 0 OR :index > 8) OR {letterRegionByIndex})
            <filter>AND a.lower_name LIKE :filter</filter>
            <artist>AND t.lower_artist = LOWER(:artist) AND t.album = a.name</artist>
            <genre>AND t.lower_genre = LOWER(:genre) AND t.album = a.name</genre>
            <year>AND a.year >= :min_year AND a.year <= :max_year</year>
            GROUP BY albumname, track_count, artist_count, a.artist, a.image_hash, a.year
            ORDER BY albumname
            ]]>
        </sql>
    </statement>

    <statement name="findAlbumsRestricted">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT a.name AS albumname, a.track_count AS track_count, a.artist_count AS artist_count, a.artist AS artist, a.image_hash AS image_hash, a.year AS year
            FROM album a, link_track_playlist rltp, track t
            WHERE ((:index < 0 OR :index > 8) OR {letterRegionByIndex})
            <filter>AND a.lower_name LIKE :filter</filter>
            <artist>AND t.lower_artist = LOWER(:artist) AND t.album = a.name</artist>
            <genre>AND t.lower_genre = LOWER(:genre) AND t.album = a.name</genre>
            <year>AND a.year >= :min_year AND a.year <= :max_year</year>
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
            AND t.album = a.name
            GROUP BY albumname, track_count, artist_count, a.artist, a.image_hash, a.year
            ORDER BY albumname
            ]]>
        </sql>
    </statement>

    <statement name="findAlbumsSortByYear">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT a.name AS albumname, a.track_count AS track_count, a.artist_count AS artist_count, a.artist AS artist, a.image_hash AS image_hash, a.year AS year
            FROM album a <track>, track t</track>
            WHERE ((:index < 0 OR :index > 8) OR {letterRegionByIndex}))
            <filter>AND a.lower_name LIKE :filter</filter>
            <artist>AND t.lower_artist = LOWER(:artist) AND t.album = a.name</artist>
            <genre>AND t.lower_genre = LOWER(:genre) AND t.album = a.name</genre>
            <year>AND a.year >= :min_year AND a.year <= :max_year</year>
            GROUP BY albumname, track_count, artist_count, a.artist, a.image_hash, a.year
            ORDER BY year
            ]]>
        </sql>
    </statement>

    <statement name="findAlbumsRestrictedSortByYear">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT a.name AS albumname, a.track_count AS track_count, a.artist_count AS artist_count, a.artist AS artist, a.image_hash AS image_hash, a.year AS year
            FROM album a, link_track_playlist rltp, track t
            WHERE ((:index < 0 OR :index > 8) OR {letterRegionByIndex}))
            <filter>AND a.lower_name LIKE :filter</filter>
            <artist>AND t.lower_artist = LOWER(:artist) AND t.album = a.name</artist>
            <genre>AND t.lower_genre = LOWER(:genre) AND t.album = a.name</genre>
            <year>AND a.year >= :min_year AND a.year <= :max_year</year>
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
            AND t.album = a.name
            GROUP BY albumname, track_count, artist_count, a.artist, a.image_hash, a.year
            ORDER BY year
            ]]>
        </sql>
    </statement>

    <statement name="findArtists">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT name AS name, track_count AS track_count, album_count AS album_count
            FROM artist
            WHERE ((:album IS NULL AND :genre IS NULL AND (:index < 0 OR :index > 8))
            OR (:album IS NOT NULL AND name IN (SELECT DISTINCT(artist) FROM track WHERE lower_album = LOWER(:album)))
            OR (:genre IS NOT NULL AND name IN (SELECT DISTINCT(artist) FROM track WHERE lower_genre = LOWER(:genre)))
            OR {letterRegionByIndex})
            AND (:filter IS NULL OR lower_name LIKE :filter)
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findArtistsRestricted">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT a.name AS name, a.track_count AS track_count, a.album_count AS album_count
            FROM artist a, link_track_playlist rltp, track t
            WHERE ((:album IS NULL AND :genre IS NULL AND (:index < 0 OR :index > 8))
            OR (:album IS NOT NULL AND a.name IN (SELECT DISTINCT(artist) FROM track WHERE lower_album = LOWER(:album)))
            OR (:genre IS NOT NULL AND a.name IN (SELECT DISTINCT(artist) FROM track WHERE lower_genre = LOWER(:genre)))
            OR {letterRegionByIndex})
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
            AND t.artist = a.name
            AND (:filter IS NULL OR a.lower_name LIKE :filter)
            GROUP BY a.name, a.track_count, a.album_count
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findArtistTrackCount">
        <sql>
            SELECT track_count AS count FROM artist WHERE lower_name = LOWER(:name)
        </sql>
    </statement>

    <statement name="findGenreTrackCount">
        <sql>
            SELECT track_count AS count FROM genre WHERE lower_name = LOWER(:name)
        </sql>
    </statement>

    <statement name="findGenres">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT name AS name, track_count AS track_count, artist_count AS artist_count, album_count AS album_count
            FROM genre
            WHERE (:index < 0 OR :index > 8)
            OR {letterRegionByIndex}
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findGenresRestricted">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT g.name AS name, g.track_count AS track_count, g.artist_count AS artist_count, g.album_count AS album_count
            FROM genre g, link_track_playlist rltp, track t
            WHERE ((:index < 0 OR :index > 8) OR {letterRegionByIndex})
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
            AND t.genre = g.name
            GROUP BY g.name, g.track_count, g.artist_count, g.album_count
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylists">
        <sql>
            <![CDATA[
            SELECT id AS id, name AS name, type AS type, track_count AS track_count, user_private AS user_private, hidden AS hidden, user_owner AS user_owner, container_id AS container_id
            FROM playlist
            WHERE (hidden IS NULL OR :includeHidden = TRUE OR hidden = FALSE)
            AND (type != 'TEMP')
            AND (user_private IS NULL OR user_private = FALSE OR :username IS NULL OR user_owner = :username)
            AND ((:size_of_types = 0 AND :id IS NULL)
            OR (:size_of_types > 0 AND :id IS NULL AND type IN (:types[]))
            OR (:size_of_types = 0 AND :id IS NOT NULL AND id = :id)
            OR (:size_of_types > 0 AND :id IS NOT NULL AND type IN (:types[]) AND id = :id))
            AND (:containerId IS NULL OR (:containerId = 'ROOT' AND container_id IS NULL) OR (:containerId != 'ROOT' AND container_id = :containerId))
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findUserPlaylists">
        <sql>
            <![CDATA[
            SELECT id AS id, name AS name, type AS type, track_count AS track_count, user_private AS user_private, hidden AS hidden, user_owner AS user_owner, container_id AS container_id
            FROM playlist
            WHERE (hidden IS NULL OR :includeHidden = TRUE OR hidden = FALSE)
            AND (type != 'TEMP')
            AND user_owner = :username
            AND ((:size_of_types = 0 AND :id IS NULL)
            OR (:size_of_types > 0 AND :id IS NULL AND type IN (:types[]))
            OR (:size_of_types = 0 AND :id IS NOT NULL AND id = :id)
            OR (:size_of_types > 0 AND :id IS NOT NULL AND type IN (:types[]) AND id = :id))
            AND (:containerId IS NULL OR (:containerId = 'ROOT' AND container_id IS NULL) OR (:containerId != 'ROOT' AND container_id = :containerId))
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistsRestricted">
        <sql>
            <![CDATA[
            SELECT p.id AS id, p.name AS name, p.type AS type, p.track_count AS track_count, user_private AS user_private, hidden AS hidden, user_owner AS user_owner, container_id AS container_id
            FROM playlist p, link_track_playlist rltp, link_track_playlist ltp
            WHERE (hidden IS NULL OR :includeHidden = TRUE OR hidden = FALSE)
            AND (user_private IS NULL OR user_private = FALSE OR :username IS NULL OR user_owner = :username)
            AND (type != 'TEMP')
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND ltp.track_id = rltp.track_id
            AND ltp.playlist_id = p.id
            AND ((:size_of_types = 0 AND :id IS NULL)
            OR (:size_of_types > 0 AND :id IS NULL AND p.type IN (:types[]))
            OR (:size_of_types = 0 AND :id IS NOT NULL AND p.id = :id)
            OR (:size_of_types > 0 AND :id IS NOT NULL AND p.type IN (:types[]) AND p.id = :id))
            AND (:containerId IS NULL OR (:containerId = 'ROOT' AND container_id IS NULL) OR (:containerId != 'ROOT' AND container_id = :containerId))
            GROUP BY id, name, type, track_count, user_private, hidden, user_owner, container_id
            ORDER BY name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracksOrderedByIndex">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT ltp.idx AS idx, {trackColumns}
            FROM link_track_playlist ltp, track t
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            AND (:firstIndex = -1 OR ltp.idx >= :firstIndex)
            AND (:lastIndex = -1 OR ltp.idx <= :lastIndex)
            ORDER BY idx
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracksOrderedByIndexRestricted">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT ltp.idx AS idx, {trackColumns}
            FROM link_track_playlist ltp, link_track_playlist rltp, track t
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND t.id = rltp.track_id
            AND (:firstIndex = -1 OR ltp.idx >= :firstIndex)
            AND (:lastIndex = -1 OR ltp.idx <= :lastIndex)
            ORDER BY idx
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracksOrderedByAlbum">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist ltp, track t
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            AND (:firstIndex = -1 OR ltp.idx >= :firstIndex)
            AND (:lastIndex = -1 OR ltp.idx <= :lastIndex)
            ORDER BY album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracksOrderedByAlbumRestricted">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist ltp, link_track_playlist rltp, track t
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND t.id = rltp.track_id
            AND (:firstIndex = -1 OR ltp.idx >= :firstIndex)
            AND (:lastIndex = -1 OR ltp.idx <= :lastIndex)
            ORDER BY album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracksOrderedByArtist">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist ltp, track t
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            AND (:firstIndex = -1 OR ltp.idx >= :firstIndex)
            AND (:lastIndex = -1 OR ltp.idx <= :lastIndex)
            ORDER BY artist, album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracksOrderedByArtistRestricted">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist ltp, link_track_playlist rltp, track t
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND t.id = rltp.track_id
            AND (:firstIndex = -1 OR ltp.idx >= :firstIndex)
            AND (:lastIndex = -1 OR ltp.idx <= :lastIndex)
            ORDER BY artist, album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findAllTracksOrderedByAlbum">
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM track t
            ORDER BY album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findAllTracksOrderedByAlbumRestricted">
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist rltp, track t
            WHERE rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND t.id = rltp.track_id
            ORDER BY album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findAllTracksOrderedByArtist">
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM track t
            ORDER BY artist, album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="findAllTracksOrderedByArtistRestricted">
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist rltp, track t
            WHERE rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND t.id = rltp.track_id
            ORDER BY artist, album, pos_number, track_number, name
            ]]>
        </sql>
    </statement>

    <statement name="updatePlayCountAndDate">
        <sql>
            UPDATE track SET playcount = playcount + 1, ts_played = :ts_played WHERE id IN (:id[])
        </sql>
    </statement>

    <statement name="findAllTracksForImageUpdate">
        <sql>
            SELECT id AS id, source AS source, file AS file, last_image_update AS last_image_update FROM track WHERE
            last_image_update IS NULL OR last_image_update &lt; :timeUpdateStart
        </sql>
    </statement>

    <statement name="findTracks">
      <sql>
        {findTracksQuery}
      </sql>
    </statement>

    <statement name="findTracksRestricted">
      <sql>
        {findTracksQueryRestricted}
      </sql>
    </statement>

    <statement name="findTracksWithAlbumOrder">
      <sql>
        {findTracksQuery}
        ORDER BY album, pos_number, track_number, name
      </sql>
    </statement>

    <statement name="findTracksWithAlbumOrderRestricted">
      <sql>
        {findTracksQueryRestricted}
        ORDER BY album, pos_number, track_number, name
      </sql>
    </statement>

    <statement name="findTracksWithArtistOrder">
      <sql>
        {findTracksQuery}
        ORDER BY artist, album, pos_number, track_number, name
      </sql>
    </statement>

    <statement name="findTracksWithArtistOrderRestricted">
      <sql>
        {findTracksQueryRestricted}
        ORDER BY artist, album, pos_number, track_number, name
      </sql>
    </statement>

    <statement name="findTracksByIds">
        <sql>
            {findTracksByIdsQuery}
        </sql>
    </statement>

    <statement name="findTracksByIdsRestricted">
        <sql>
            {findTracksByIdsQueryRestricted}
        </sql>
    </statement>

    <statement name="findTracksByIdsWithAlbumOrder">
        <sql>
            {findTracksByIdsQuery}
            ORDER BY album, pos_number, track_number, name
        </sql>
    </statement>

    <statement name="findTracksByIdsWithAlbumOrderRestricted">
        <sql>
            {findTracksByIdsQueryRestricted}
            ORDER BY album, pos_number, track_number, name
        </sql>
    </statement>

    <statement name="findTracksByIdsWithArtistOrder">
        <sql>
            {findTracksByIdsQuery}
            ORDER BY artist, album, pos_number, track_number, name
        </sql>
    </statement>

    <statement name="findTracksByIdsWithArtistOrderRestricted">
        <sql>
            {findTracksByIdsQueryRestricted}
            ORDER BY artist, album, pos_number, track_number, name
        </sql>
    </statement>

    <statement name="deletePlaylistById">
        <sql>
            DELETE FROM playlist WHERE id = :id
        </sql>
    </statement>

    <statement name="deleteOrphanedImages">
        <sql>
            DELETE FROM image WHERE NOT EXISTS ( SELECT * FROM track t WHERE t.image_hash = hash )
        </sql>
    </statement>

    <statement name="findTrackIdsForSource">
        <sql>
            SELECT id AS id FROM track WHERE source = :source
        </sql>
    </statement>

    <statement name="getSystemInformation">
        <sql>
            SELECT lastupdate AS lastupdate, version AS version, track_count AS track_count, album_count AS album_count,
            artist_count AS artist_count, genre_count AS genre_count
            FROM system_information
        </sql>
    </statement>

    <statement name="initializeAllTables">
        <sql>INSERT INTO system_information (version) VALUES (:version)</sql>
    </statement>

    <statement name="updateDatabaseVersion">
        <sql>UPDATE system_information SET version = :version</sql>
    </statement>

    <statement name="insertImage">
        <sql>INSERT INTO image (hash, size, data) VALUES (:hash, :size, :data)</sql>
    </statement>

    <statement name="updateImageForTrack">
            <sql>UPDATE track SET image_hash = :hash WHERE id = :track_id</sql>
        <sql>
            UPDATE track SET last_image_update = :updateTime WHERE id = :track_id
        </sql>
    </statement>

    <statement name="getTrackIds">
        <sql>
            SELECT id AS id FROM track
        </sql>
    </statement>

    <statement name="removeTrack">
        <sql loop="track_id" loopbatch="10000" loopcommit="10000">DELETE FROM track WHERE id = :loopitem_track_id</sql>
    </statement>

    <statement name="findImage">
        <sql>
            SELECT data AS data FROM image WHERE hash = :hash AND size = :size
        </sql>
    </statement>

    <statement name="findTrackImage">
        <sql>
            SELECT i.data AS data FROM image AS i, track AS t WHERE i.hash = t.image_hash AND size = :size AND t.id = :track_id
        </sql>
    </statement>

    <statement name="insertTrack">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <sql>
            INSERT INTO track (id, name, lower_name, artist, lower_artist, original_artist, album, lower_album, time, track_number, file, protected, mediatype, source, genre, lower_genre, suffix, mp4codec, ts_updated, playcount, last_image_update, comment, pos_number, pos_size, year)
            VALUES (:id, :name, LOWER(:name), :artist, LOWER(:artist), :original_artist, :album, LOWER(:album), :time, :track_number, :file, :protected, :mediatype, :source, :genre, LOWER(:genre), :suffix, :mp4codec, :ts_updated, 0, 0, :comment, :pos_number, :pos_size, :year)
        </sql>
    </statement>

    <statement name="insertTrackAndImage">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <sql>
            INSERT INTO track (id, name, lower_name, artist, lower_artist, original_artist, album, lower_album, time, track_number, file, protected, mediatype, source, genre, lower_genre, suffix, mp4codec, ts_updated, playcount, last_image_update, comment, pos_number, pos_size, year)
            VALUES (:id, :name, LOWER(:name), :artist, LOWER(:artist), :original_artist, :album, LOWER(:album), :time, :track_number, :file, :protected, :mediatype, :source, :genre, LOWER(:genre), :suffix, :mp4codec, :ts_updated, 0, :ts_updated, :comment, :pos_number, :pos_size, :year)
        </sql>
    </statement>

    <statement name="updateTrack">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <sql>
            UPDATE track SET name = :name, album = :album, artist = :artist, original_artist = :original_artist, time = :time, track_number = :track_number,
                             file = :file, protected = :protected, mediatype = :mediatype, genre = :genre, suffix = :suffix, mp4codec = :mp4codec,
                             ts_updated = :ts_updated, comment = :comment, pos_number = :pos_number, pos_size = :pos_size, lower_genre = LOWER(:genre), lower_artist = LOWER(:artist),
                             lower_name = LOWER(:name), lower_album = LOWER(:album), lower_comment = LOWER(:comment), year = :year
            WHERE id = :id
        </sql>
    </statement>

    <statement name="updateTrackFileType">
        <sql>
            UPDATE track SET protected = :protected, mediatype = :mediatype WHERE suffix = :suffix
        </sql>
    </statement>

    <statement name="updateTrackAndImage">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <sql>
            UPDATE track SET name = :name, album = :album, artist = :artist, original_artist = :original_artist, time = :time, track_number = :track_number,
                             file = :file, protected = :protected, mediatype = :mediatype, genre = :genre, suffix = :suffix, mp4codec = :mp4codec,
                             ts_updated = :ts_updated, comment = :comment, last_image_update = :ts_updated, pos_number = :pos_number,
                             pos_size = :pos_size, lower_genre = LOWER(:genre), lower_artist = LOWER(:artist), lower_name = LOWER(:name), lower_album = LOWER(:album),
                             lower_comment = LOWER(:comment), year = :year
            WHERE id = :id
        </sql>
    </statement>

    <statement name="insertPlaylist">
        <sql>INSERT INTO playlist (id, name, type, track_count, hidden, user_private, user_owner, ts_create, container_id) VALUES (:id, :name, :type, 0, FALSE, :user_private, :user_name, :ts, :container_id)</sql>
        <sql loop="track_id" loopbatch="10000" loopcommit="10000">{createPlaylistTrackLinks}</sql>
        <sql>{updatePlaylistCount}</sql>
    </statement>

    <statement name="updatePlaylist">
        <sql>UPDATE playlist SET name = :name, user_private = :user_private, container_id = :container_id WHERE id = :id</sql>
        <sql>DELETE FROM link_track_playlist WHERE playlist_id = :id</sql>
        <sql loop="track_id" loopbatch="10000" loopcommit="10000">{createPlaylistTrackLinks}</sql>
        <sql>{updatePlaylistCount}</sql>
    </statement>

    <statement name="updatePlaylistAttributes">
        <sql>UPDATE playlist SET name = :name, hidden = :hidden, user_owner = :user_owner, user_private = :user_private WHERE id = :id</sql>
    </statement>

    <statement name="recreateHelpTablesAlbum">
        <sql>DELETE FROM album</sql>
        <sql>
            INSERT INTO album (name, lower_name, first_char, artist, track_count, artist_count, image_hash, year)
            SELECT MAX(album), MAX(lower_album), SUBSTRING(MAX(lower_album) FROM 1 FOR 1), MAX(artist), COUNT(id), COUNT(DISTINCT(lower_artist)), MAX(image_hash), MAX(year) FROM track GROUP BY lower_album
        </sql>
    </statement>

    <statement name="recreateHelpTablesArtist">
        <sql>DELETE FROM artist</sql>
        <sql>
            INSERT INTO artist (name, lower_name, first_char, track_count, album_count)
            SELECT MAX(artist), lower_artist, SUBSTRING(MAX(lower_artist) FROM 1 FOR 1), COUNT(id), COUNT(DISTINCT(lower_album)) FROM track GROUP BY lower_artist
        </sql>
    </statement>

    <statement name="recreateHelpTablesGenre">
        <sql>DELETE FROM genre</sql>
        <sql>
            INSERT INTO genre (name, lower_name, first_char, track_count, album_count, artist_count)
            SELECT MAX(genre), lower_genre, SUBSTRING(MAX(lower_genre) FROM 1 FOR 1), COUNT(id), COUNT(DISTINCT(lower_album)), COUNT(DISTINCT(lower_artist)) FROM track WHERE genre IS NOT NULL GROUP BY lower_genre
        </sql>
    </statement>

    <statement name="findPlaylistIds">
        <sql>SELECT id AS id FROM playlist WHERE type IN (:types[])</sql>
    </statement>

    <statement name="updateStatistics">
        <sql>UPDATE system_information SET track_count = (SELECT COUNT(id) FROM track)</sql>
        <sql>UPDATE system_information SET album_count = (SELECT COUNT(name) FROM album)</sql>
        <sql>UPDATE system_information SET artist_count = (SELECT COUNT(name) FROM artist)</sql>
        <sql>UPDATE system_information SET genre_count = (SELECT COUNT(name) FROM genre)</sql>
    </statement>

    <statement name="removeTempPlaylistWithId">
        <sql>DELETE FROM playlist WHERE id = :id AND type = 'TEMP'</sql>
    </statement>

    <statement name="getTempPlaylistCreationTime">
        <sql>SELECT ts_create AS ts FROM playlist WHERE type = 'TEMP' ORDER BY ts DESC</sql>
    </statement>

    <statement name="removeOldTempPlaylists">
        <sql>DELETE FROM playlist WHERE type = 'TEMP' AND ts_create &lt; :ts</sql>
    </statement>

    <statement name="insertStatisticsEvent">
        <sql>INSERT INTO statistics (ts_create, data) VALUES (:ts, :data)</sql>
    </statement>

    <statement name="removeOldStatisticEvents">
        <sql>DELETE FROM statistics WHERE ts_create &lt; :ts</sql>
    </statement>

    <statement name="getStatisticEvents">
        <sql>
            SELECT ts_create AS ts, data AS data
            FROM statistics
            WHERE ts_create &gt;= :ts_from AND ts_create &lt; :ts_to
            ORDER BY ts
        </sql>
    </statement>

    <statement name="insertSmartInfo">
        <parameter name="time_min" type="java.lang.Integer"/>
        <parameter name="time_max" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <sql>
            INSERT INTO smart_info (playlist_id, album_pattern, artist_pattern, genre_pattern, title_pattern,
                                    file_pattern, time_min, time_max, mediatype, protected)
            VALUES (:playlist_id, :album_pattern, :artist_pattern, :genre_pattern, :title_pattern,
                    :file_pattern, :time_min, :time_max, :mediatype, :protected)
        </sql>
    </statement>

    <statement name="findSmartPlaylistById">
        <sql>
            SELECT
                p.name AS name, p.track_count AS track_count, p.user_private AS user_private, p.hidden AS hidden,
                p.user_owner AS user_owner, p.container_id AS container_id,
                si.album_pattern AS album_pattern, si.artist_pattern AS artist_pattern, si.genre_pattern AS genre_pattern,
                si.title_pattern AS title_pattern, si.file_pattern AS file_pattern, si.time_min AS time_min,
                si.time_max AS time_max, si.mediatype AS mediatype, si.protected AS protected
            FROM
                playlist p, smart_info si
            WHERE
                p.id = :id AND si.playlist_id = :id
        </sql>
    </statement>

    <statement name="updateSmartInfo">
        <parameter name="time_min" type="java.lang.Integer"/>
        <parameter name="time_max" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <sql>
            UPDATE
                smart_info
            SET
                album_pattern = :album_pattern,
                artist_pattern = :artist_pattern,
                genre_pattern = :genre_pattern,
                title_pattern = :title_pattern,
                file_pattern = :file_pattern,
                time_min = :time_min,
                time_max = :time_max,
                mediatype = :mediatype,
                protected = :protected
            WHERE
                playlist_id = :playlist_id
        </sql>
    </statement>

    <statement name="refreshSmartPlaylists">
        <sql>
            DELETE FROM
                link_track_playlist
            WHERE
                playlist_id IN (SELECT playlist_id FROM smart_info)
        </sql>
        <sql>
            INSERT INTO
                link_track_playlist (playlist_id, track_id)
                SELECT si.playlist_id, t.id FROM smart_info si, track t
                    WHERE (si.album_pattern IS NULL OR t.lower_album LIKE LOWER(si.album_pattern))
                    AND (si.artist_pattern IS NULL OR t.lower_artist LIKE LOWER(si.artist_pattern))
                    AND (si.genre_pattern IS NULL OR t.lower_genre LIKE LOWER(si.genre_pattern))
                    AND (si.title_pattern IS NULL OR t.lower_name LIKE LOWER(si.title_pattern))
                    AND (si.file_pattern IS NULL OR LOWER(t.file) LIKE LOWER(si.file_pattern))
                    AND (si.time_min IS NULL OR t.time &gt;= si.time_min)
                    AND (si.time_max IS NULL OR t.time &lt;= si.time_max)
                    AND (si.mediatype IS NULL OR t.mediatype = si.mediatype)
                    AND (si.protected IS NULL OR t.protected = si.protected)
                ORDER BY t.album, t.pos_number, t.track_number, t.name
        </sql>
        <sql>
            UPDATE
                playlist p
            SET
                track_count = (SELECT COUNT(playlist_id) FROM link_track_playlist WHERE playlist_id = p.id)
            WHERE
                p.id IN (SELECT si.playlist_id FROM smart_info si)
        </sql>
    </statement>

    <statement name="truncateSearchTempTables">
        <sql>TRUNCATE TABLE temp_lucene_tracks</sql>
        <sql>TRUNCATE TABLE temp_like_tracks</sql>
    </statement>

    <statement name="fillLuceneSearchTempTable">
        <sql loop="track_id" loopbatch="10000">
            INSERT INTO temp_lucene_tracks (track_id) VALUES (:loopitem_track_id)
        </sql>
    </statement>

    <statement name="fillLikeSearchTempTable">
        <sql>
            INSERT INTO temp_like_tracks (track_id)
                SELECT DISTINCT(t.id) FROM track t, tag tg
                WHERE (
                    t.lower_name LIKE :first_search_term {likeEscape}
                    OR t.lower_album LIKE :first_search_term {likeEscape}
                    OR t.lower_artist LIKE :first_search_term {likeEscape}
                    OR t.lower_comment LIKE :first_search_term {likeEscape}
                    OR (
                        tg.tag LIKE :first_search_term {likeEscape}
                        AND tg.track_id = t.id
                    )
                )
        </sql>
        <sql loop="search_term" loopbatch="100">
            DELETE FROM temp_like_tracks
            WHERE NOT EXISTS (
                SELECT t.id FROM track t, tag tg
                WHERE t.id = temp_like_tracks.track_id
                AND (
                    t.lower_name LIKE :loopitem_search_term {likeEscape}
                    OR t.lower_album LIKE :loopitem_search_term {likeEscape}
                    OR t.lower_artist LIKE :loopitem_search_term {likeEscape}
                    OR t.lower_comment LIKE :loopitem_search_term {likeEscape}
                    OR (
                        tg.tag LIKE :first_search_term {likeEscape}
                        AND tg.track_id = t.id
                    )
                )
            )
        </sql>
    </statement>

    <statement name="findAllTags">
        <sql>
            SELECT DISTINCT(tag)
            FROM tag
            WHERE :query IS NULL OR tag LIKE :query {likeEscape}
            ORDER BY tag;
        </sql>
    </statement>

    <statement name="findAllTagsForTrack">
        <sql>
            SELECT DISTINCT(tag) FROM tag WHERE track_id = :track_id ORDER BY tag;
        </sql>
    </statement>

    <statement name="findAllTagsForPlaylist">
        <sql>
            SELECT DISTINCT(t.tag) FROM tag t, link_track_playlist ltp
            WHERE ltp.playlist_id = :playlist_id
            AND ltp.track_id = t.track_id
        </sql>
    </statement>

    <statement name="findAllTagsForAlbum">
        <sql>
            SELECT DISTINCT(t.tag) FROM tag t, track tr
            WHERE tr.album = :album
            AND tr.id = t.track_id
        </sql>
    </statement>

    <statement name="findAllTagsForArtist">
        <sql>
            SELECT DISTINCT(t.tag) FROM tag t, track tr
            WHERE tr.artist = :artist
            AND tr.id = t.track_id
        </sql>
    </statement>

    <statement name="setTagToTracks">
        <sql loop="track_id" loopbatch="1000">
            DELETE FROM tag WHERE track_id = :loopitem_track_id AND tag = LOWER(:tag)
        </sql>
        <sql loop="track_id" loopbatch="1000">
            INSERT INTO tag (track_id, tag) VALUES (:loopitem_track_id, LOWER(:tag))
        </sql>
    </statement>

    <statement name="removeTagFromTracks">
        <sql loop="track_id" loopbatch="1000">
            DELETE FROM tag WHERE track_id = :loopitem_track_id AND tag = LOWER(:tag)
        </sql>
    </statement>

    <statement name="getTrackTagMap">
        <sql>
            SELECT t.id, tg.tag FROM track t, tag tg WHERE t.id = tg.track_id
        </sql>
    </statement>

    <!-- reusable sql fragments -->
    <fragment name="letterRegionByIndex">
        <![CDATA[
        (:index = 0 AND (first_char < 'a' OR first_char > 'z'))
        OR (:index = 1 AND first_char >= 'a' AND first_char < 'd')
        OR (:index = 2 AND first_char >= 'd' AND first_char < 'g')
        OR (:index = 3 AND first_char >= 'g' AND first_char < 'j')
        OR (:index = 4 AND first_char >= 'j' AND first_char < 'm')
        OR (:index = 5 AND first_char >= 'm' AND first_char < 'p')
        OR (:index = 6 AND first_char >= 'p' AND first_char < 't')
        OR (:index = 7 AND first_char >= 't' AND first_char < 'w')
        OR (:index = 8 AND first_char >= 'w' AND first_char <= 'z')
        ]]>
    </fragment>

    <fragment name="trackColumns">
        t.source AS source, t.id AS id, t.name AS name, t.artist AS artist, t.original_artist AS original_artist, t.album AS album, t.time AS time, t.track_number AS track_number,
        t.file AS file, t.protected AS protected, t.mediatype AS mediatype, t.genre AS genre, t.mp4codec AS mp4codec, t.ts_played AS ts_played, t.ts_updated AS ts_updated,
        t.playcount AS playcount, t.last_image_update AS last_image_update, t.comment AS comment, t.pos_number AS pos_number, t.pos_size AS pos_size, t.image_hash AS image_hash,
        t.year AS year
    </fragment>

    <fragment name="updatePlaylistCount">
        UPDATE playlist
        SET track_count = (SELECT COUNT(*) FROM link_track_playlist WHERE playlist_id = :id)
        WHERE id = :id
    </fragment>

    <fragment name="createPlaylistTrackLinks">
        INSERT INTO link_track_playlist (idx, playlist_id, track_id) VALUES (:loopindex_track_id, :id, :loopitem_track_id)
    </fragment>

    <fragment name="findTracksQuery">
        <![CDATA[
        SELECT {trackColumns}
        FROM track t
        WHERE (:size_of_genre = 0 OR t.lower_genre IN (:genre[]))
        AND (:size_of_artist = 0 OR t.lower_artist IN (:artist[]))
        AND (:size_of_album = 0 OR t.lower_album IN (:album[]))
        ]]>
    </fragment>

    <fragment name="findTracksByIdsQuery">
        <![CDATA[
            SELECT {trackColumns}
            FROM temp_lucene_tracks tt, track t
            WHERE tt.track_id = t.id
        UNION
            SELECT {trackColumns}
            FROM temp_like_tracks tt, track t
            WHERE tt.track_id = t.id
        ]]>
    </fragment>

    <fragment name="findTracksQueryRestricted">
        <![CDATA[
        SELECT {trackColumns}
        FROM link_track_playlist rltp, track t
        WHERE rltp.playlist_id IN (:restrictedPlaylistIds[])
        AND rltp.track_id = t.id
        AND (:size_of_genre = 0 OR t.lower_genre IN (:genre[]))
        AND (:size_of_artist = 0 OR t.lower_artist IN (:artist[]))
        AND (:size_of_album = 0 OR t.lower_album IN (:album[]))
        ]]>
    </fragment>

    <fragment name="findTracksByIdsQueryRestricted">
        <![CDATA[
            SELECT {trackColumns}
            FROM link_track_playlist rltp, temp_lucene_tracks tt, track t
            WHERE rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
            AND tt.track_id = t.id
        UNION
            SELECT {trackColumns}
            FROM link_track_playlist rltp, temp_like_tracks tt, track t
            WHERE rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
            AND tt.track_id = t.id
        ]]>
    </fragment>

</statements>