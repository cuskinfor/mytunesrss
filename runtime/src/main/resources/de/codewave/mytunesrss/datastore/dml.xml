<?xml version="1.0" encoding="UTF-8"?>

<statements>

    <statement name="findAlbums">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT a.name AS albumname, a.track_count AS track_count, a.artist_count AS artist_count, a.artist AS artist, a.image_hash AS image_hash, a.year AS year
            FROM album a<track>, track t</track><restricted>, link_track_playlist rltp</restricted>
            WHERE {alwaysTrueCondition}
            <compilation>AND a.compilation = :compilation</compilation>
            <index>AND ({letterRegionByIndex})</index>
            <filter>AND a.lower_name LIKE :filter ESCAPE '!'</filter>
            <albumartist>AND t.lower_album_artist = :artist AND t.album = a.name</albumartist>
            <artist>AND (t.lower_artist = :artist OR t.lower_album_artist = :artist) AND t.album = a.name AND t.album_artist = a.artist</artist>
            <genre>AND t.lower_genre = :genre AND t.album = a.name</genre>
            <year>AND a.year >= :min_year AND a.year <= :max_year</year>
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND rltp.track_id = t.id
                AND t.album = a.name
            </restricted>
            <excluded>
                AND t.album = a.name
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            GROUP BY a.name, a.track_count, a.artist_count, a.artist, a.image_hash, a.year
            <albumorder>ORDER BY LOWER(a.name), a.name</albumorder>
            <yearorder>ORDER BY year</yearorder>
            ]]>
        </sql>
    </statement>

    <statement name="findArtists">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT a.name AS name, a.track_count AS track_count, a.album_count AS album_count
            FROM artist a<track>, track t</track><restricted>, link_track_playlist rltp</restricted>
            WHERE {alwaysTrueCondition}
            <index>AND ({letterRegionByIndex})</index>
            <filter>AND a.lower_name LIKE :filter ESCAPE '!'</filter>
            <album>AND t.lower_album = :album AND (t.artist = a.name OR t.album_artist = a.name)</album>
            <genre>AND t.lower_genre = :genre AND (t.artist = a.name OR t.album_artist = a.name)</genre>
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND rltp.track_id = t.id
                AND t.artist = a.name
            </restricted>
            <excluded>
                AND t.artist = a.name
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            GROUP BY LOWER(a.name), a.name, a.track_count, a.album_count
            ORDER BY LOWER(a.name), a.name
            ]]>
        </sql>
    </statement>

    <statement name="findArtistTrackCount">
        <sql>
            SELECT COUNT(id) AS count FROM track WHERE lower_artist = LOWER(:name) OR lower_album_artist = LOWER(:name)
        </sql>
    </statement>

    <statement name="findGenreTrackCount">
        <sql>
            SELECT track_count AS count FROM genre WHERE lower_name = LOWER(:name)
        </sql>
    </statement>

    <statement name="findGenres">
        <parameter name="index" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT g.name AS name, g.track_count AS track_count, g.artist_count AS artist_count, g.album_count AS album_count, g.hidden AS hidden
            FROM genre g<restricted>, link_track_playlist rltp</restricted><track>, track t</track>
            WHERE {alwaysTrueCondition}
            <index>AND ({letterRegionByIndex})</index>
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND rltp.track_id = t.id
                AND t.genre = g.name
            </restricted>
            <excluded>
                AND t.genre = g.name
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            <nohidden>AND (g.hidden IS NULL OR g.hidden = FALSE)</nohidden>
            GROUP BY LOWER(g.name), g.name, g.track_count, g.artist_count, g.album_count, g.hidden
            ORDER BY LOWER(g.name), g.name
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylists">
        <sql>
            <![CDATA[
            SELECT p.id AS id, p.name AS name, p.type AS type, p.track_count AS track_count, user_private AS user_private, hidden AS hidden, user_owner AS user_owner, container_id AS container_id
            FROM playlist p<restricted>, link_track_playlist rltp</restricted><restricted_or_excluded>, link_track_playlist ltp</restricted_or_excluded>
            WHERE type != 'TEMP' AND type != 'Random'
            <nohidden>AND (hidden IS NULL OR hidden = FALSE)</nohidden>
            <matching>AND user_owner = :username</matching>
            <user>AND (user_private IS NULL OR user_private = FALSE OR user_owner = :username)</user>
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND ltp.track_id = rltp.track_id
                AND ltp.playlist_id = p.id
            </restricted>
            <excluded>
                AND p.id NOT IN (:excludedPlaylistIds[])
                AND ltp.playlist_id = p.id
                AND ltp.track_id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            <hidden>
                AND p.id NOT IN (:hiddenPlaylistIds[])
            </hidden>
            <types>AND p.type IN (:types[])</types>
            <id>AND p.id = :id</id>
            <container>AND container_id = :containerId</container>
            <rootcontainer>AND container_id IS NULL</rootcontainer>
            GROUP BY id, name, type, track_count, user_private, hidden, user_owner, container_id
            ORDER BY LOWER(name), name
            ]]>
        </sql>
    </statement>

    <statement name="findRandomPlaylist">
        <sql>
            <![CDATA[
            SELECT p.id AS id, p.name AS name, p.type AS type, p.track_count AS track_count, user_private AS user_private, hidden AS hidden, user_owner AS user_owner, container_id AS container_id
            FROM playlist p
            WHERE type = 'Random'
            AND user_owner = :username
            ]]>
        </sql>
    </statement>

    <statement name="findPlaylistTracks">
        <default name="firstIndex" value="-1" type="java.lang.Integer"/>
        <default name="lastIndex" value="-1" type="java.lang.Integer"/>
        <sql>
            <![CDATA[
            SELECT ltp.idx AS idx, {trackColumns}
            FROM link_track_playlist ltp, track t<restricted>, link_track_playlist rltp</restricted>
            WHERE t.id = ltp.track_id
            AND ltp.playlist_id = :id
            <index>AND ltp.idx >= :firstIndex</index>
            <index>AND ltp.idx <= :lastIndex</index>
            <restricted>
                AND ltp.playlist_id = :id
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND t.id = rltp.track_id
            </restricted>
            <excluded>
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            GROUP BY ltp.idx, {trackColumnsForGrouping}
            <indexorder>ORDER BY idx</indexorder>
            <albumorder>ORDER BY LOWER(album), album, pos_number, track_number, LOWER(name), name</albumorder>
            <artistorder>ORDER BY LOWER(artist), artist, album, pos_number, track_number, LOWER(name), name</artistorder>
            ]]>
        </sql>
    </statement>

    <statement name="findAllTracks">
        <sql>
            <![CDATA[
            SELECT {trackColumns}
            FROM track t<restricted>, link_track_playlist rltp</restricted>
            WHERE {alwaysTrueCondition}
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND t.id = rltp.track_id
            </restricted>
            <excluded>
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            GROUP BY {trackColumnsForGrouping}
            <albumorder>ORDER BY LOWER(album), album, pos_number, track_number, LOWER(name), name</albumorder>
            <artistorder>ORDER BY LOWER(artist), artist, album, pos_number, track_number, LOWER(name), name</artistorder>
            ]]>
        </sql>
    </statement>

    <statement name="updatePlayCountAndDate">
        <sql>
            UPDATE track SET playcount = playcount + 1, ts_played = :ts_played WHERE id IN (:id[])
        </sql>
    </statement>

    <statement name="findAllTracksForImageUpdate">
        <sql>
            SELECT id AS id, source AS source, file AS file, last_image_update AS last_image_update FROM track WHERE
            (last_image_update IS NULL OR last_image_update &lt; :timeUpdateStart) AND source_id in (:source_id[])
        </sql>
    </statement>

    <statement name="findTracks">
      <sql>
        <![CDATA[
        SELECT {trackColumns}
        FROM track t<restricted>, link_track_playlist rltp</restricted><temptables>, temp_lucene_tracks tluc</temptables>
        WHERE {alwaysTrueCondition}
        <genre>AND t.lower_genre IN (:genre[])</genre>
        <artist>AND (t.lower_artist IN (:artist[]) OR t.lower_album_artist IN (:artist[]))</artist>
        <albumartist>AND t.lower_album_artist IN (:albumartist[])</albumartist>
        <album>AND t.lower_album IN (:album[])</album>
        <mediatype>AND t.mediatype IN (:mediaTypes[])</mediatype>
        <videotype>AND t.videotype = :videoType</videotype>
        <tvshow>AND t.series = :series</tvshow>
        <tvshowseason>AND t.season = :season</tvshowseason>
        <restricted>
            AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND rltp.track_id = t.id
        </restricted>
        <excluded>
            AND t.id NOT IN (
                SELECT eltp.track_id FROM link_track_playlist eltp
                WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
            )
        </excluded>
        <temptables>AND t.id = tluc.track_id</temptables>
        GROUP BY <lucenesort>tluc.pos, </lucenesort>{trackColumnsForGrouping}
        <lucenesort>ORDER BY tluc.pos</lucenesort>
        <albumsort>ORDER BY LOWER(t.album), t.album, t.pos_number, t.track_number, LOWER(t.name), t.name</albumsort>
        <artistsort>ORDER BY LOWER(t.artist), t.artist, t.album, t.pos_number, t.track_number, LOWER(t.name), t.name</artistsort>
        <moviesort>ORDER BY LOWER(t.name), t.name</moviesort>
        <tvshowsort>ORDER BY LOWER(t.series), t.series, t.season, t.episode, LOWER(t.name), t.name</tvshowsort>
        ]]>
      </sql>
    </statement>

    <statement name="deletePlaylistById">
        <sql>
            DELETE FROM playlist WHERE id = :id
        </sql>
    </statement>

    <!-- delete playlists with non-existent owner users -->
    <statement name="deleteOrphanedPlaylists">
        <sql>
            DELETE FROM playlist WHERE user_owner NOT IN (:existingUsers[])
        </sql>
    </statement>

    <!-- rename owner of playlists -->
    <statement name="renamePlaylistOwner">
        <sql>
            UPDATE playlist SET user_owner = :newUsername WHERE user_owner = :oldUsername
        </sql>
    </statement>

    <statement name="getImageSizes">
        <sql>SELECT size FROM image WHERE hash = :hash ORDER BY size</sql>
    </statement>

    <statement name="findTrackIdsForSource">
        <sql>
            SELECT id AS id FROM track WHERE source = :source
        </sql>
    </statement>

    <statement name="getSystemInformation">
        <sql>
            SELECT lastupdate AS lastupdate, version AS version, track_count AS track_count, album_count AS album_count,
            artist_count AS artist_count, genre_count AS genre_count, music_count AS music_count, movie_count AS movie_count,
            tvshow_count AS tvshow_count, photo_count AS photo_count
            FROM system_information
        </sql>
    </statement>

    <statement name="initializeAllTables">
        <sql>INSERT INTO system_information (version) VALUES (:version)</sql>
    </statement>

    <statement name="updateDatabaseVersion">
        <sql>UPDATE system_information SET version = :version</sql>
    </statement>

    <statement name="insertImage">
        <sql>INSERT INTO image (hash, size, mimetype, data) VALUES (:hash, :size, :mimetype, :data)</sql>
    </statement>

    <statement name="updateImage">
        <sql>UPDATE image SET data = :data, mimetype = :mimetype WHERE hash = :hash AND size = :size</sql>
    </statement>

    <statement name="updateImageForTrack">
        <sql>UPDATE track SET image_hash = :hash WHERE id = :track_id</sql>
        <sql>
            UPDATE track SET last_image_update = :updateTime WHERE id = :track_id
        </sql>
    </statement>

    <statement name="getTrackIds">
        <sql>
            SELECT id AS id FROM track
        </sql>
    </statement>

    <statement name="removeTrack">
        <sql loop="track_id" loopbatch="10000" loopcommit="10000">DELETE FROM track WHERE id = :loopitem_track_id AND source_id in (:source_id[])</sql>
    </statement>

    <statement name="removeImagesForDataSources">
        <sql>UPDATE track SET image_hash = NULL WHERE source_id IN (:source_id[])</sql>
        <sql>UPDATE photo SET image_hash = NULL WHERE source_id IN (:source_id[])</sql>
    </statement>

    <statement name="removePhoto">
        <sql loop="photo_id" loopbatch="10000" loopcommit="10000">DELETE FROM photo WHERE id = :loopitem_photo_id AND source_id in (:source_id[])</sql>
    </statement>

    <statement name="findImage">
        <sql>
            SELECT mimetype, data AS data FROM image WHERE hash = :hash AND size = :size
        </sql>
    </statement>

    <statement name="findMaxSizeImage">
        <sql>
            SELECT im1.mimetype, im1.data AS data FROM image im1
            LEFT OUTER JOIN image im2 ON (im1.hash = im2.hash AND im1.size &lt; im2.size)
            WHERE im1.hash = :hash AND im2.hash IS NULL
        </sql>
    </statement>

    <statement name="findTrackImage">
        <sql>
            SELECT i.mimetype, i.data AS data FROM image AS i, track AS t WHERE i.hash = t.image_hash AND size = :size AND t.id = :track_id
        </sql>
    </statement>

    <statement name="insertTrack">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <parameter name="videotype" type="java.lang.String"/>
        <parameter name="episode" type="java.lang.Integer"/>
        <parameter name="season" type="java.lang.Integer"/>
        <sql>
            INSERT INTO track (id, name, lower_name, artist, lower_artist, original_artist, album_artist, lower_album_artist, original_album_artist, album, lower_album, time, track_number, file, protected, mediatype, source, genre, lower_genre, suffix, mp4codec, ts_updated, playcount, last_image_update, comment, pos_number, pos_size, year, series, lower_series, season, episode, videotype, composer, compilation, source_id)
            VALUES (:id, :name, LOWER(:name), :artist, LOWER(:artist), :original_artist, :album_artist, LOWER(:album_artist), :original_album_artist, :album, LOWER(:album), :time, :track_number, :file, :protected, :mediatype, :source, :genre, LOWER(:genre), :suffix, :mp4codec, :ts_updated, 0, 0, :comment, :pos_number, :pos_size, :year, :series, LOWER(:series), :season, :episode, :videotype, :composer, :compilation, :source_id)
        </sql>
    </statement>

    <statement name="insertTrackAndImage">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <parameter name="videotype" type="java.lang.String"/>
        <parameter name="episode" type="java.lang.Integer"/>
        <parameter name="season" type="java.lang.Integer"/>
        <sql>
            INSERT INTO track (id, name, lower_name, artist, lower_artist, original_artist, album_artist, lower_album_artist, original_album_artist, album, lower_album, time, track_number, file, protected, mediatype, source, genre, lower_genre, suffix, mp4codec, ts_updated, playcount, last_image_update, comment, pos_number, pos_size, year, series, lower_series, season, episode, videotype, composer, compilation, source_id)
            VALUES (:id, :name, LOWER(:name), :artist, LOWER(:artist), :original_artist, :album_artist, LOWER(:album_artist), :original_album_artist, :album, LOWER(:album), :time, :track_number, :file, :protected, :mediatype, :source, :genre, LOWER(:genre), :suffix, :mp4codec, :ts_updated, 0, :ts_updated, :comment, :pos_number, :pos_size, :year, :series, LOWER(:series), :season, :episode, :videotype, :composer, :compilation, :source_id)
        </sql>
    </statement>

    <statement name="updateTrack">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <parameter name="videotype" type="java.lang.String"/>
        <parameter name="episode" type="java.lang.Integer"/>
        <parameter name="season" type="java.lang.Integer"/>
        <sql>
            UPDATE track SET name = :name, album = :album, artist = :artist, original_artist = :original_artist, time = :time, track_number = :track_number,
                             file = :file, protected = :protected, mediatype = :mediatype, genre = :genre, suffix = :suffix, mp4codec = :mp4codec,
                             ts_updated = :ts_updated, comment = :comment, pos_number = :pos_number, pos_size = :pos_size, lower_genre = LOWER(:genre), lower_artist = LOWER(:artist),
                             lower_name = LOWER(:name), lower_album = LOWER(:album), lower_comment = LOWER(:comment), year = :year,
                             series = :series, lower_series = LOWER(:series), season = :season, episode = :episode, videotype = :videotype,
                             album_artist = :album_artist, lower_album_artist = LOWER(:album_artist), original_album_artist = :original_album_artist, composer = :composer,
                             compilation = :compilation, source_id = :source_id, image_hash = NULL
            WHERE id = :id
        </sql>
    </statement>

    <statement name="updateTrackFileType">
        <sql>
            UPDATE track SET protected = :protected, mediatype = :mediatype, videotype = :videotype WHERE suffix = :suffix
        </sql>
    </statement>

    <statement name="updateTrackAndImage">
        <parameter name="time" type="java.lang.Integer"/>
        <parameter name="track_number" type="java.lang.Integer"/>
        <parameter name="protected" type="java.lang.Boolean"/>
        <parameter name="mediatype" type="java.lang.String"/>
        <parameter name="videotype" type="java.lang.String"/>
        <parameter name="episode" type="java.lang.Integer"/>
        <parameter name="season" type="java.lang.Integer"/>
        <sql>
            UPDATE track SET name = :name, album = :album, artist = :artist, original_artist = :original_artist, time = :time, track_number = :track_number,
                             file = :file, protected = :protected, mediatype = :mediatype, genre = :genre, suffix = :suffix, mp4codec = :mp4codec,
                             ts_updated = :ts_updated, comment = :comment, last_image_update = :ts_updated, pos_number = :pos_number,
                             pos_size = :pos_size, lower_genre = LOWER(:genre), lower_artist = LOWER(:artist), lower_name = LOWER(:name), lower_album = LOWER(:album),
                             lower_comment = LOWER(:comment), year = :year, series = :series, lower_series = LOWER(:series), season = :season, episode = :episode,
                             videotype = :videotype, album_artist = :album_artist, lower_album_artist = LOWER(:album_artist), original_album_artist = :original_album_artist,
                             composer = :composer, compilation = :compilation, source_id = :source_id
            WHERE id = :id
        </sql>
    </statement>

    <statement name="insertPlaylist">
        <sql>INSERT INTO playlist (id, name, type, track_count, hidden, user_private, user_owner, ts_create, container_id, updated, source_id) VALUES (:id, :name, :type, 0, FALSE, :user_private, :user_name, :ts, :container_id, TRUE, :source_id)</sql>
        <sql loop="track_id" loopbatch="10000" loopcommit="10000">{createPlaylistTrackLinks}</sql>
        <sql>{updatePlaylistCount}</sql>
    </statement>

    <statement name="updatePlaylist">
        <sql>UPDATE playlist SET name = :name, user_private = :user_private, container_id = :container_id, updated = TRUE, source_id = :source_id WHERE id = :id</sql>
        <sql>DELETE FROM link_track_playlist WHERE playlist_id = :id</sql>
        <sql loop="track_id" loopbatch="10000" loopcommit="10000">{createPlaylistTrackLinks}</sql>
        <sql>{updatePlaylistCount}</sql>
    </statement>

    <statement name="updatePlaylistAttributes">
        <sql>UPDATE playlist SET name = :name, hidden = :hidden, user_owner = :user_owner, user_private = :user_private WHERE id = :id</sql>
    </statement>

    <statement name="updateGenreHiddenAttribute">
        <sql>UPDATE genre SET hidden = :hidden WHERE name = :name</sql>
    </statement>

    <statement name="insertPhoto">
        <sql>INSERT INTO photo (id, name, date, file, source_id) VALUES (:id, :name, :date, :file, :source_id)</sql>
    </statement>

    <statement name="updatePhoto">
        <sql>UPDATE photo SET name = :name, date = :date, file = :file, source_id = :source_id, image_hash = NULL WHERE id = :id</sql>
    </statement>

    <statement name="getPhotoAlbumIds">
        <sql>SELECT id FROM photoalbum</sql>
    </statement>

    <statement name="getPhotoIds">
        <sql>SELECT id FROM photo</sql>
    </statement>

    <statement name="findPhotos">
        <sql>
            <![CDATA[
            SELECT p.id AS id, p.name AS name, p.file AS file, p.date AS date, p.image_hash AS image_hash, p.last_image_update AS last_image_update
            FROM photo p, link_photo_album lpa<restricted>, link_photo_album rlpa</restricted>
            WHERE p.id = lpa.photo_id
            AND lpa.album_id = :album_id
            <restricted>
                AND rlpa.album_id IN (:restrictedPhotoAlbumIds[])
                AND rlpa.photo_id = p.id
            </restricted>
            <excluded>
                AND p.id NOT IN (
                    SELECT elpa.photo_id FROM link_photo_album elpa
                    WHERE elpa.album_id IN (:excludedPhotoAlbumIds[])
                )
            </excluded>
            <excludedDatasources>
                AND p.source_id NOT IN (:excludedDataSourceIds[])
            </excludedDatasources>
            GROUP BY id, name, file, date, image_hash, last_image_update
            ORDER BY date, LOWER(name), name
            ]]>
        </sql>
    </statement>

    <statement name="getPhoto">
        <sql>
            SELECT p.id AS id, p.name AS name, p.file AS file, p.date AS date, p.image_hash AS image_hash, p.last_image_update AS last_image_update
            FROM photo p
            WHERE p.id = :id
        </sql>
    </statement>

    <statement name="getDataSourceIds">
        <sql>
            SELECT source_id FROM track WHERE source_id IS NOT NULL
            UNION SELECT source_id FROM photo WHERE source_id IS NOT NULL
            UNION SELECT source_id FROM photoalbum WHERE source_id IS NOT NULL
            UNION SELECT source_id FROM playlist WHERE source_id IS NOT NULL
        </sql>
    </statement>

    <statement name="cleanupPlaylistsAndPhotoAlbumsAfterUpdate">
        <sql>DELETE FROM playlist WHERE updated = FALSE AND source_id in (:source_id[])</sql>
        <sql>UPDATE playlist SET updated = FALSE</sql>
        <sql>DELETE FROM photoalbum WHERE updated = FALSE AND source_id in (:source_id[])</sql>
        <sql>UPDATE photoalbum SET updated = FALSE</sql>
    </statement>

    <statement name="finishDatabaseUpdate">
        <sql>
            DELETE FROM image
            WHERE NOT EXISTS
            ( SELECT * FROM track t WHERE t.image_hash = hash )
            AND NOT EXISTS
            ( SELECT * FROM photo p WHERE p.image_hash = hash )
        </sql>
    </statement>

    <statement name="updateImageForPhoto">
        <sql>UPDATE photo SET image_hash = :hash, last_image_update = :updateTime WHERE id = :photo_id</sql>
    </statement>

    <statement name="insertPhotoAlbum">
        <sql>INSERT INTO photoalbum (id, name, source_id, updated) VALUES (:id, :name, :source_id, TRUE)</sql>
        <sql loop="photo_id" loopbatch="10000" loopcommit="10000">{createPhotoAlbumLinks}</sql>
        <sql>{updatePhotoAlbumCountAndDates}</sql>
        <sql>{correctPhotoAlbumFirstDates}</sql>
    </statement>

    <statement name="updatePhotoAlbum">
        <sql>UPDATE photoalbum SET name = :name, source_id = :source_id, updated = TRUE WHERE id = :id</sql>
        <sql>DELETE FROM link_photo_album WHERE album_id = :id</sql>
        <sql loop="photo_id" loopbatch="10000" loopcommit="10000">{createPhotoAlbumLinks}</sql>
        <sql>{updatePhotoAlbumCountAndDates}</sql>
        <sql>{correctPhotoAlbumFirstDates}</sql>
    </statement>

    <statement name="addPhotosToAlbum">
        <sql loop="photo_id" loopbatch="10000" loopcommit="10000">{createPhotoAlbumLinks}</sql>
        <sql>{updatePhotoAlbumCountAndDates}</sql>
        <sql>{correctPhotoAlbumFirstDates}</sql>
    </statement>

    <statement name="checkPhotoAlbumLink">
        <sql>SELECT 0 FROM link_photo_album WHERE album_id = :album AND photo_id = :photo</sql>
    </statement>

    <statement name="recreateHelpTablesAlbum">
        <sql>DELETE FROM album</sql>
        <sql>
            INSERT INTO album (name, lower_name, first_char, artist, track_count, artist_count, image_hash, year, compilation)
            SELECT MAX(album), MAX(lower_album), SUBSTRING(MAX(lower_album) FROM 1 FOR 1), MAX(album_artist), COUNT(id), COUNT(DISTINCT(lower_album_artist)), MAX(image_hash), MAX(year), MAX(compilation) FROM track WHERE mediatype = 'Audio' GROUP BY lower_album, lower_album_artist
        </sql>
    </statement>

    <statement name="recreateHelpTablesArtist">
        <sql>DELETE FROM artist</sql>
        <sql>
            INSERT INTO artist (name, lower_name, first_char, track_count, album_count)
            SELECT MAX(album_artist), lower_album_artist, SUBSTRING(lower_album_artist FROM 1 FOR 1), 0, 0 FROM track WHERE mediatype = 'Audio' GROUP BY lower_album_artist
        </sql>
        <sql>
            UPDATE artist SET track_count = (
                (SELECT COUNT(id) FROM track WHERE lower_artist = artist.lower_name)
                + (SELECT COUNT(id) FROM track WHERE lower_artist != artist.lower_name AND lower_album_artist = artist.lower_name)
            )
        </sql>
        <sql>
            UPDATE artist SET album_count = (
                (SELECT COUNT(DISTINCT(album)) FROM track WHERE lower_artist = artist.lower_name)
                + (SELECT COUNT(DISTINCT(album)) FROM track WHERE lower_artist != artist.lower_name AND lower_album_artist = artist.lower_name)
            )
        </sql>
    </statement>

    <statement name="recreateHelpTablesGenre">
        <sql>DELETE FROM genre</sql>
        <sql>
            INSERT INTO genre (name, lower_name, first_char, track_count, album_count, artist_count, hidden)
            SELECT MAX(genre), lower_genre, SUBSTRING(MAX(lower_genre) FROM 1 FOR 1), COUNT(id), COUNT(DISTINCT(lower_album)), COUNT(DISTINCT(lower_album_artist)), FALSE FROM track WHERE genre IS NOT NULL AND mediatype = 'Audio' GROUP BY lower_genre
        </sql>
        <sql loop="hidden_genres" loopbatch="1000" loopcommit="1000">UPDATE genre SET hidden = TRUE WHERE name = :loopitem_hidden_genres</sql>
    </statement>

    <statement name="findPlaylistIds">
        <sql>SELECT id AS id FROM playlist WHERE type IN (:types[])</sql>
    </statement>

    <statement name="updateStatistics">
        <sql>UPDATE system_information SET track_count = (SELECT COUNT(id) FROM track)</sql>
        <sql>UPDATE system_information SET album_count = (SELECT COUNT(name) FROM album)</sql>
        <sql>UPDATE system_information SET artist_count = (SELECT COUNT(name) FROM artist)</sql>
        <sql>UPDATE system_information SET genre_count = (SELECT COUNT(name) FROM genre)</sql>
        <sql>UPDATE system_information SET music_count = (SELECT COUNT(id) FROM track WHERE mediatype = 'Audio')</sql>
        <sql>UPDATE system_information SET movie_count = (SELECT COUNT(name) FROM track WHERE mediatype = 'Video' AND videotype = 'Movie')</sql>
        <sql>UPDATE system_information SET tvshow_count = (SELECT COUNT(name) FROM track WHERE mediatype = 'Video' AND videotype = 'TvShow')</sql>
        <sql>UPDATE system_information SET photo_count = (SELECT COUNT(id) FROM photo WHERE EXISTS (SELECT * FROM link_photo_album WHERE link_photo_album.photo_id = photo.id))</sql>
    </statement>

    <statement name="removeTempPlaylistWithId">
        <sql>DELETE FROM playlist WHERE id = :id AND type = 'TEMP'</sql>
    </statement>

    <statement name="getTempPlaylistCreationTime">
        <sql>SELECT ts_create AS ts FROM playlist WHERE type = 'TEMP' ORDER BY ts DESC</sql>
    </statement>

    <statement name="removeOldTempPlaylists">
        <sql>DELETE FROM playlist WHERE type = 'TEMP' AND ts_create &lt; :ts</sql>
    </statement>

    <statement name="insertStatisticsEvent">
        <sql>INSERT INTO statistics (ts_create, type, data) VALUES (:ts, :type, :data)</sql>
    </statement>

    <statement name="removeOldStatisticEvents">
        <sql>DELETE FROM statistics WHERE ts_create &lt; :ts</sql>
    </statement>

    <statement name="getStatisticEvents">
        <sql>
            <![CDATA[
            SELECT ts_create AS ts, type AS type, data AS data
            FROM statistics
            WHERE ts_create >= :ts_from AND ts_create <= :ts_to
            <types>AND type IN (:type[])</types>
            ORDER BY ts
            ]]>
        </sql>
    </statement>

    <statement name="insertSmartInfo">
        <sql loop="param">
            INSERT INTO smart_info (playlist_id, field_type, pattern, invert) VALUES (:playlist_id, :loopitem_param[0], :loopitem_param[1], :loopitem_param[2])
        </sql>
    </statement>

    <statement name="findSmartPlaylistById">
        <sql>
            SELECT
                p.id AS id, p.name AS name, p.track_count AS track_count, p.user_private AS user_private, p.hidden AS hidden,
                p.user_owner AS user_owner, p.container_id AS container_id,
                si.field_type AS smart_field_type, si.pattern AS smart_pattern, si.invert AS smart_invert
            FROM
                playlist p, smart_info si
            WHERE
                p.id = :id AND si.playlist_id = :id
        </sql>
    </statement>

    <statement name="updateSmartInfo">
        <sql>
            DELETE FROM smart_info WHERE playlist_id = :playlist_id
        </sql>
        <sql loop="param">
            INSERT INTO smart_info (playlist_id, field_type, pattern, invert) VALUES (:playlist_id, :loopitem_param[0], :loopitem_param[1], :loopitem_param[2])
        </sql>
    </statement>

    <statement name="findAllSmartPlaylists">
        <sql>
            SELECT
                p.id AS id, p.name AS name, p.track_count AS track_count, p.user_private AS user_private, p.hidden AS hidden,
                p.user_owner AS user_owner, p.container_id AS container_id,
                si.field_type AS smart_field_type, si.pattern AS smart_pattern, si.invert AS smart_invert
            FROM
                playlist p, smart_info si
            WHERE
                p.id = si.playlist_id
        </sql>
    </statement>

    <statement name="refreshSmartPlaylist">
        <!-- lock playlist table first -->
        <sql>
            SELECT id FROM playlist FOR UPDATE
        </sql>
        <sql>
            DELETE FROM
                link_track_playlist
            WHERE
                playlist_id = :id
        </sql>
        <sql>
            <![CDATA[
            INSERT INTO
                link_track_playlist (playlist_id, track_id)
                SELECT :id, t.id
                FROM track t
                <lucene>, temp_lucene_tracks tluc WHERE t.id = tluc.track_id</lucene>
                <nolucene>WHERE t.id IS NOT NULL</nolucene>
                <mintime>AND t.time >= :time_min</mintime>
                <maxtime>AND t.time <= :time_max</maxtime>
                <mediatype>AND t.mediatype = :mediatype</mediatype>
                <videotype>AND t.videotype = :videotype</videotype>
                <protected>AND t.protected = :protected</protected>
                <datasource>AND t.source_id = :source_id</datasource>
                ORDER BY <lucene>tluc.pos, </lucene>LOWER(t.artist), t.artist, LOWER(t.album), t.album, t.pos_number, t.track_number, LOWER(t.name), t.name
            ]]>
        </sql>
        <sql>
            UPDATE
                playlist p
            SET
                track_count = (SELECT COUNT(playlist_id) FROM link_track_playlist WHERE playlist_id = :id)
            WHERE
                p.id = :id
        </sql>
    </statement>

    <statement name="truncateSearchTempTables">
        <sql>TRUNCATE TABLE temp_lucene_tracks</sql>
    </statement>

    <statement name="fillLuceneSearchTempTable">
        <sql loop="track_id" loopbatch="10000">
            INSERT INTO temp_lucene_tracks (track_id) VALUES (:loopitem_track_id)
        </sql>
    </statement>

    <statement name="findAllTags">
        <sql>
            <![CDATA[
            SELECT DISTINCT(tag)
            FROM tag
            <query>WHERE tag LIKE :query ESCAPE '!'</query>
            ORDER BY LOWER(tag), tag
            ]]>
        </sql>
    </statement>

    <statement name="findAllTagsForTrack">
        <sql>
            SELECT DISTINCT(tag) FROM tag WHERE track_id = :track_id ORDER BY LOWER(tag), tag;
        </sql>
    </statement>

    <statement name="findAllTagsForPlaylist">
        <sql>
            SELECT DISTINCT(t.tag) FROM tag t, link_track_playlist ltp
            WHERE ltp.playlist_id = :playlist_id
            AND ltp.track_id = t.track_id
        </sql>
    </statement>

    <statement name="findAllTagsForAlbum">
        <sql>
            SELECT DISTINCT(t.tag) FROM tag t, track tr
            WHERE tr.album = :album
            AND tr.album_artist = :artist
            AND tr.id = t.track_id
        </sql>
    </statement>

    <statement name="findAllTagsForArtist">
        <sql>
            SELECT DISTINCT(t.tag) FROM tag t, track tr
            WHERE tr.artist = :artist
            AND tr.id = t.track_id
        </sql>
    </statement>

    <statement name="setTagToTracks">
        <sql loop="track_id" loopbatch="1000">
            DELETE FROM tag WHERE track_id = :loopitem_track_id AND tag = LOWER(:tag)
        </sql>
        <sql loop="track_id" loopbatch="1000">
            INSERT INTO tag (track_id, tag) VALUES (:loopitem_track_id, LOWER(:tag))
        </sql>
    </statement>

    <statement name="removeTagFromTracks">
        <sql loop="track_id" loopbatch="1000">
            DELETE FROM tag WHERE track_id = :loopitem_track_id AND tag = LOWER(:tag)
        </sql>
    </statement>

    <statement name="getTrackTagMap">
        <sql>
            SELECT t.id, tg.tag FROM track t, tag tg WHERE t.id = tg.track_id
        </sql>
    </statement>

    <statement name="findRandomTracks">
        <sql>
            <![CDATA[
            {selectLimitedTracks}
            FROM track t<restricted>, link_track_playlist rltp</restricted><sourceplaylist>, link_track_playlist spltp</sourceplaylist>
            WHERE {alwaysTrueCondition}
            <unprotectedonly>AND NOT t.protected</unprotectedonly>
            <mediatype>AND t.mediatype = :mediatype</mediatype>
            <videotype>AND t.videotype = :videotype</videotype>
            <sourceplaylist>
                AND spltp.playlist_id = :sourcePlaylistId
                AND t.id = spltp.track_id
            </sourceplaylist>
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND t.id = rltp.track_id
            </restricted>
            <excluded>
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            {findRandomTracksOrderClause}
            ]]>
        </sql>
    </statement>

    <statement name="findLastUpdatedTracks">
        <sql>
            <![CDATA[
            {selectLimitedTracks}
            FROM track t<restricted>, link_track_playlist rltp</restricted>
            WHERE {alwaysTrueCondition}
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND t.id = rltp.track_id
            </restricted>
            <excluded>
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            {findLastUpdatedTracksOrderClause}
            ]]>
        </sql>
    </statement>

    <statement name="findMostPlayedTracks">
        <sql>
            <![CDATA[
            {selectLimitedTracks}
            FROM track t<restricted>, link_track_playlist rltp</restricted>
            WHERE {alwaysTrueCondition}
            <restricted>
                AND rltp.playlist_id IN (:restrictedPlaylistIds[])
                AND t.id = rltp.track_id
            </restricted>
            <excluded>
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            {findMostPlayedTracksOrderClause}
            ]]>
        </sql>
    </statement>

    <statement name="findRecentlyPlayedTracks">
        <sql>
            <![CDATA[
            {selectLimitedTracks}
            FROM track t<restricted>, link_track_playlist rltp</restricted>
            WHERE t.ts_played IS NOT NULL
            <restricted>AND rltp.playlist_id IN (:restrictedPlaylistIds[])
            AND t.id = rltp.track_id</restricted>
            <excluded>
                AND t.id NOT IN (
                    SELECT eltp.track_id FROM link_track_playlist eltp
                    WHERE eltp.playlist_id IN (:excludedPlaylistIds[])
                )
            </excluded>
            {findRecentlyPlayedTracksOrderClause}
            ]]>
        </sql>
    </statement>

    <statement name="getPhotoAlbums">
        <sql>
            <![CDATA[
            SELECT pa.id AS id, pa.name AS name, pa.first_date AS first_date, pa.last_date AS last_date, pa.photo_count AS photo_count
            FROM photoalbum pa<restricted>, link_photo_album rlpa</restricted><restricted_or_excluded>, link_photo_album lpa</restricted_or_excluded>
            WHERE {alwaysTrueCondition}
            <restricted>
                AND rlpa.album_id IN (:restrictedPhotoAlbumIds[])
                AND lpa.photo_id = rlpa.photo_id
                AND lpa.album_id = pa.id
            </restricted>
            <excluded>
                AND pa.id NOT IN (:excludedPhotoAlbumIds[])
                AND lpa.album_id = pa.id
                AND lpa.photo_id NOT IN (
                    SELECT elpa.photo_id FROM link_photo_album elpa
                    WHERE elpa.album_id IN (:excludedPhotoAlbumIds[])
                )
            </excluded>
            <excludedDatasources>
                AND pa.source_id NOT IN (:excludedDataSourceIds[])
                AND lpa.album_id = pa.id
                AND lpa.photo_id NOT IN (
                    SELECT edsp.id FROM photo edsp
                    WHERE edsp.source_id IN (:excludedDataSourceIds[])
                )
            </excludedDatasources>
            GROUP BY id, name, first_date, last_date, photo_count
            ORDER BY first_date, last_date, LOWER(name), name
            ]]>
        </sql>
    </statement>

    <statement name="getPhotosWithMissingThumbnails">
        <sql>SELECT id, file FROM photo WHERE image_hash IS NULL</sql>
    </statement>

    <statement name="getPhotoImageHashAndFile">
        <sql>SELECT image_hash, file FROM photo WHERE id = :id</sql>
    </statement>

    <statement name="getTracksWithMissingImages">
        <sql>SELECT id, file, source FROM track WHERE image_hash IS NULL</sql>
    </statement>

    <!-- reusable sql fragments -->
    <fragment name="letterRegionByIndex">
        <![CDATA[
        (:index = 0 AND (first_char < 'a' OR first_char > 'z'))
        OR (:index = 1 AND first_char >= 'a' AND first_char < 'd')
        OR (:index = 2 AND first_char >= 'd' AND first_char < 'g')
        OR (:index = 3 AND first_char >= 'g' AND first_char < 'j')
        OR (:index = 4 AND first_char >= 'j' AND first_char < 'm')
        OR (:index = 5 AND first_char >= 'm' AND first_char < 'p')
        OR (:index = 6 AND first_char >= 'p' AND first_char < 't')
        OR (:index = 7 AND first_char >= 't' AND first_char < 'w')
        OR (:index = 8 AND first_char >= 'w' AND first_char <= 'z')
        ]]>
    </fragment>

    <fragment name="trackColumns">
        t.source AS source, t.id AS id, t.name AS name, t.artist AS artist, t.original_artist AS original_artist, t.album AS album, t.time AS time, t.track_number AS track_number,
        t.file AS file, t.protected AS protected, t.mediatype AS mediatype, t.genre AS genre, t.mp4codec AS mp4codec, t.ts_played AS ts_played, t.ts_updated AS ts_updated,
        t.playcount AS playcount, t.last_image_update AS last_image_update, t.comment AS comment, t.pos_number AS pos_number, t.pos_size AS pos_size, t.image_hash AS image_hash,
        t.year AS year, t.videotype AS videotype, t.series AS series, t.season AS season, t.episode AS episode, t.composer AS composer, t.album_artist AS album_artist
    </fragment>

    <fragment name="trackColumnsForGrouping">
        t.source, t.id, t.name, t.artist, t.original_artist, t.album, t.time, t.track_number, t.file, t.protected, t.mediatype, t.genre, t.mp4codec, t.ts_played, t.ts_updated,
        t.playcount, t.last_image_update, t.comment, t.pos_number, t.pos_size, t.image_hash, t.year, t.videotype, t.series, t.season, t.episode, t.composer, t.album_artist
    </fragment>

    <fragment name="updatePlaylistCount">
        UPDATE playlist
        SET track_count = (SELECT COUNT(*) FROM link_track_playlist WHERE playlist_id = :id)
        WHERE id = :id
    </fragment>

    <fragment name="createPlaylistTrackLinks">
        INSERT INTO link_track_playlist (idx, playlist_id, track_id) VALUES (:loopindex_track_id, :id, :loopitem_track_id)
    </fragment>

    <fragment name="updatePhotoAlbumCountAndDates">
        UPDATE photoalbum
        SET
            photo_count = (SELECT COUNT(*) FROM link_photo_album WHERE album_id = :id),
            first_date = (SELECT MIN(date) FROM photo p, link_photo_album lpa WHERE lpa.photo_id = p.id AND lpa.album_id = :id),
            last_date = (SELECT MAX(date) FROM photo p, link_photo_album lpa WHERE lpa.photo_id = p.id AND lpa.album_id = :id)
        WHERE id = :id
    </fragment>

    <fragment name="correctPhotoAlbumFirstDates">
        UPDATE photoalbum
        SET first_date = last_date
        WHERE first_date = -1
    </fragment>

    <fragment name="createPhotoAlbumLinks">
        INSERT INTO link_photo_album (album_id, photo_id) VALUES (:id, :loopitem_photo_id)
    </fragment>

    <fragment name="alwaysTrueCondition">
        <![CDATA[
            0 = 0
        ]]>
    </fragment>

</statements>