<?xml version="1.0" encoding="UTF-8"?>

<statements>

    <statement name="findRandomTracks">
        <sql>
            SELECT {trackColumns}, COUNT(i.hash) AS imagecount
            FROM track t
            LEFT OUTER JOIN image i ON i.hash = t.image_hash
            WHERE (:sourcePlaylistId IS NULL OR EXISTS (SELECT * FROM link_track_playlist ltp WHERE ltp.track_id = t.id AND
                ltp.playlist_id = :sourcePlaylistId))
            AND (:mediatype IS NULL OR t.mediatype = :mediatype)
            AND (NOT t.protected OR t.protected = :protected)
            GROUP BY {groupByTrackColumns}
            ORDER BY random() LIMIT :maxCount OFFSET 0
        </sql>
    </statement>

    <statement name="findLastUpdatedTracks">
        <sql>
            SELECT {trackColumns}, COUNT(i.hash) AS imagecount
            FROM track t
            LEFT OUTER JOIN image i ON i.hash = t.image_hash
            WHERE :sourcePlaylistId IS NULL OR EXISTS (SELECT * FROM link_track_playlist ltp WHERE ltp.track_id = t.id AND
                ltp.playlist_id = :sourcePlaylistId)
            GROUP BY {groupByTrackColumns}
            ORDER BY ts_updated DESC LIMIT :maxCount OFFSET 0
        </sql>
    </statement>

    <statement name="findMostPlayedTracks">
        <sql>
            SELECT {trackColumns}, COUNT(i.hash) AS imagecount
            FROM track t
            LEFT OUTER JOIN image i ON i.hash = t.image_hash
            WHERE :sourcePlaylistId IS NULL OR EXISTS (SELECT * FROM link_track_playlist ltp WHERE ltp.track_id = t.id AND
                ltp.playlist_id = :sourcePlaylistId)
            GROUP BY {groupByTrackColumns}
            ORDER BY playcount DESC LIMIT :maxCount OFFSET 0
        </sql>
    </statement>

    <statement name="findRandomTracksRestricted">
        <sql>
            SELECT {trackColumns}, COUNT(i.hash) AS imagecount
            FROM link_track_playlist rltp, track t
            LEFT OUTER JOIN image i ON i.hash = t.image_hash
            WHERE (:sourcePlaylistId IS NULL OR EXISTS (SELECT * FROM link_track_playlist ltp WHERE
                ltp.track_id = t.id AND ltp.playlist_id = :sourcePlaylistId))
            AND rltp.playlist_id = :restrictedPlaylistId AND t.id = rltp.track_id
            AND (:mediatype IS NULL OR t.mediatype = :mediatype)
            AND (NOT t.protected OR t.protected = :protected)
            GROUP BY {groupByTrackColumns}
            ORDER BY random() LIMIT :maxCount OFFSET 0
        </sql>
    </statement>

    <statement name="findLastUpdatedTracksRestricted">
        <sql>
            SELECT {trackColumns}, COUNT(i.hash) AS imagecount
            FROM tlink_track_playlist rltp, rack t
            LEFT OUTER JOIN image i ON i.hash = t.image_hash
            WHERE :sourcePlaylistId IS NULL OR EXISTS (SELECT * FROM link_track_playlist ltp WHERE ltp.track_id = t.id AND
                ltp.playlist_id = :sourcePlaylistId)
            AND rltp.playlist_id = :restrictedPlaylistId AND t.id = rltp.track_id
            GROUP BY {groupByTrackColumns}
            ORDER BY ts_updated DESC LIMIT :maxCount OFFSET 0
        </sql>
    </statement>

    <statement name="findMostPlayedTracksRestricted">
        <sql>
            SELECT {trackColumns}, COUNT(i.hash) AS imagecount
            FROM link_track_playlist rltp, track t
            LEFT OUTER JOIN image i ON i.hash = t.image_hash
            WHERE :sourcePlaylistId IS NULL OR EXISTS (SELECT * FROM link_track_playlist ltp WHERE ltp.track_id = t.id AND
                ltp.playlist_id = :sourcePlaylistId)
            AND rltp.playlist_id = :restrictedPlaylistId AND t.id = rltp.track_id
            GROUP BY {groupByTrackColumns}
            ORDER BY playcount DESC LIMIT :maxCount OFFSET 0
        </sql>
    </statement>

    <statement name="findAlbumImage">
        <sql>
            SELECT data AS data FROM image i, track t WHERE t.album = :album AND i.hash = t.image_hash AND i.size = :size LIMIT 1 OFFSET 0
        </sql>
    </statement>

    <statement name="nextPlaylistId">
        <sql>SELECT nextval('playlist_id_sequence') AS id FROM system_information</sql>
    </statement>

    <statement name="nextSearchId">
        <sql>SELECT nextval('search_id_sequence') AS id FROM system_information</sql>
    </statement>

    <statement name="tuneDatabase">
        <sql>ANALYZE</sql>
    </statement>

    <statement name="preFindTracksByIds">
        <sql>
            CREATE TEMPORARY TABLE temp_track_ids (
                track_id VARCHAR(100),
                UNIQUE(track_id)
            ) ON COMMIT DROP
        </sql>
        <sql loop="track_id" loopbatch="10000">
            INSERT INTO temp_track_ids (track_id) VALUES (:loopitem_track_id)
        </sql>
        <sql loop="search_term" loopbatch="100">
            INSERT INTO temp_track_ids (track_id)
                SELECT t.id FROM track t
                WHERE NOT EXISTS (SELECT tti.track_id FROM temp_track_ids tti WHERE tti.track_id = t.id)
                AND (LOWER(t.name) LIKE :loopitem_search_term {likeEscape} OR LOWER(t.album) LIKE :loopitem_search_term {likeEscape} OR LOWER(t.artist) LIKE :loopitem_search_term {likeEscape})
        </sql>
    </statement>

    <!-- reusable sql fragments -->
    <fragment name="likeEscape">ESCAPE '\\'</fragment>

</statements>